"""Tests for SensorSet bulk modification functionality using comprehensive YAML fixtures."""

from unittest.mock import MagicMock, patch

import pytest

from ha_synthetic_sensors.config_manager import FormulaConfig, SensorConfig
from ha_synthetic_sensors.exceptions import SyntheticSensorsError
from ha_synthetic_sensors.sensor_set import SensorSetModification


class TestSensorSetModifyComprehensive:
    """Test SensorSet bulk modification with comprehensive multi-phase YAML scenarios."""

    @pytest.fixture
    def load_yaml_fixture(self):
        """Load a YAML fixture file and return its contents."""

        def _load_yaml_fixture(fixture_name: str) -> str:
            import os

            fixture_path = os.path.join("tests", "yaml_fixtures", fixture_name)
            with open(fixture_path) as f:
                return f.read()

        return _load_yaml_fixture

    @pytest.fixture
    async def comprehensive_sensor_set(self, storage_manager_real, load_yaml_fixture):
        """Create a comprehensive sensor set from Phase 1 YAML."""
        await storage_manager_real.async_load()

        # Load Phase 1 YAML
        phase1_yaml = load_yaml_fixture("modify_test_phase1_initial.yaml")

        # Create sensor set from YAML
        sensor_set_id = await storage_manager_real.async_from_yaml(
            yaml_content=phase1_yaml, sensor_set_id="comprehensive_modify_test", device_identifier="test_device:modify_123"
        )

        return storage_manager_real.get_sensor_set(sensor_set_id)

    async def test_phase1_initial_state(self, comprehensive_sensor_set):
        """Test Phase 1: Verify initial comprehensive sensor set state."""
        sensor_set = comprehensive_sensor_set

        # Verify sensor set metadata
        assert sensor_set.sensor_set_id == "comprehensive_modify_test"
        assert sensor_set.metadata.device_identifier == "test_device:modify_123"
        # Note: Name is auto-generated by storage manager

        # Verify all initial sensors are present
        sensors = sensor_set.list_sensors()
        sensor_ids = [s.unique_id for s in sensors]

        expected_sensors = ["total_power", "power_efficiency", "voltage_monitor", "local_sensor", "complex_calculation"]

        assert len(sensors) == 5
        for expected_id in expected_sensors:
            assert expected_id in sensor_ids

            # Verify global settings usage
        total_power = sensor_set.get_sensor("total_power")
        assert total_power is not None
        assert "efficiency_factor" in total_power.formulas[0].formula
        # Check for attribute formulas (formulas beyond the main one)
        assert len(total_power.formulas) >= 1  # At least the main formula

        # Verify local sensor (no globals)
        local_sensor = sensor_set.get_sensor("local_sensor")
        assert local_sensor is not None
        assert local_sensor.formulas[0].variables["local_var"] == "sensor.local_temperature"
        # Check for attribute formulas
        assert len(local_sensor.formulas) >= 1  # At least the main formula

        # Verify complex calculation sensor
        complex_sensor = sensor_set.get_sensor("complex_calculation")
        assert complex_sensor is not None
        assert len(complex_sensor.formulas) >= 1  # At least the main formula
        assert "0.8" in complex_sensor.formulas[0].formula

    @patch("homeassistant.helpers.entity_registry.async_get")
    async def test_phase2_add_remove_modify(self, mock_er_async_get, comprehensive_sensor_set, load_yaml_fixture):
        """Test Phase 2: Add sensors, remove voltage_monitor, modify formulas."""
        # Setup entity registry mock
        mock_entity_registry = MagicMock()
        mock_entity_registry.async_get.return_value = None  # No existing entity
        mock_entity_registry.async_update_entity = MagicMock()
        mock_er_async_get.return_value = mock_entity_registry

        sensor_set = comprehensive_sensor_set

        # Load Phase 2 YAML to understand target state
        _phase2_yaml = load_yaml_fixture("modify_test_phase2_add_remove.yaml")

        # Create modifications to transform from Phase 1 to Phase 2

        # 1. Remove voltage_monitor
        remove_sensors = ["voltage_monitor"]

        # 2. Update existing sensors with new formulas/attributes
        updated_total_power = SensorConfig(
            unique_id="total_power",
            name="Total Power Consumption (Updated)",
            entity_id="sensor.total_power_consumption",
            formulas=[
                FormulaConfig(
                    id="total_power",
                    formula='state("main_power") * efficiency_factor * new_multiplier',
                    unit_of_measurement="W",
                    device_class="power",
                    state_class="measurement",
                )
            ],
        )

        updated_local_sensor = SensorConfig(
            unique_id="local_sensor",
            name="Local Sensor (No Globals)",
            entity_id="sensor.local_sensor",
            formulas=[
                FormulaConfig(
                    id="local_sensor",
                    formula='state("local_var") + 15',
                    variables={"local_var": "sensor.local_temperature"},
                    unit_of_measurement="°C",
                    device_class="temperature",
                    state_class="measurement",
                )
            ],
        )

        # 3. Add new sensors
        new_power_factor = SensorConfig(
            unique_id="new_power_factor",
            name="Power Factor Calculator",
            entity_id="sensor.power_factor_calculator",
            formulas=[
                FormulaConfig(
                    id="new_power_factor",
                    formula='state("main_power") / (state("main_voltage") * state("current_var"))',
                    variables={"current_var": "sensor.house_current"},
                    unit_of_measurement="",
                    state_class="measurement",
                )
            ],
        )

        new_energy_cost = SensorConfig(
            unique_id="energy_cost",
            name="Energy Cost Estimator",
            entity_id="sensor.energy_cost_estimator",
            formulas=[
                FormulaConfig(
                    id="energy_cost",
                    formula='(state("main_power") / 1000) * efficiency_factor * cost_per_kwh',
                    variables={"cost_per_kwh": 0.12},
                    unit_of_measurement="$/hr",
                    state_class="measurement",
                )
            ],
        )

        # 4. Update global settings
        new_global_settings = {
            "variables": {
                "main_power": "sensor.house_power_meter",
                "main_voltage": "sensor.house_voltage",
                "efficiency_factor": 0.92,  # Changed from 0.95
                "new_multiplier": 1.1,  # Added new variable
            },
            "device_identifier": "test_device:modify_123",
        }

        # Apply all modifications in one bulk operation
        modification = SensorSetModification(
            remove_sensors=remove_sensors,
            update_sensors=[updated_total_power, updated_local_sensor],
            add_sensors=[new_power_factor, new_energy_cost],
            global_settings=new_global_settings,
        )

        # Apply all modifications in one bulk operation
        result = await sensor_set.async_modify(modification)

        # Verify modification results
        assert result["sensors_removed"] == 1
        assert result["sensors_updated"] == 2
        assert result["sensors_added"] == 2
        assert result["global_settings_updated"] is True

        # Verify final state
        sensors = sensor_set.list_sensors()
        sensor_ids = [s.unique_id for s in sensors]

        # Should have 6 sensors now (5 original - 1 removed + 2 added)
        assert len(sensors) == 6
        assert "voltage_monitor" not in sensor_ids  # Removed
        assert "new_power_factor" in sensor_ids  # Added
        assert "energy_cost" in sensor_ids  # Added

        # Verify updated sensors
        updated_total = sensor_set.get_sensor("total_power")
        assert updated_total.name == "Total Power Consumption (Updated)"
        assert "new_multiplier" in updated_total.formulas[0].formula

        updated_local = sensor_set.get_sensor("local_sensor")
        assert "15" in updated_local.formulas[0].formula

    @patch("homeassistant.helpers.entity_registry.async_get")
    async def test_phase3_bulk_entity_changes(self, mock_er_async_get, comprehensive_sensor_set, load_yaml_fixture):
        """Test Phase 3: Bulk entity ID changes across all sensors."""
        # Setup entity registry mock
        mock_entity_registry = MagicMock()
        mock_entity_registry.async_get.return_value = None  # No existing entity
        mock_entity_registry.async_update_entity = MagicMock()
        mock_er_async_get.return_value = mock_entity_registry

        sensor_set = comprehensive_sensor_set

        # Apply Phase 2 changes first (simulate accumulated state)
        prep_mod = SensorSetModification(
            remove_sensors=["voltage_monitor"],
            add_sensors=[
                SensorConfig(
                    unique_id="new_power_factor",
                    name="Power Factor Calculator",
                    entity_id="sensor.power_factor_calculator",
                    formulas=[FormulaConfig(id="new_power_factor", formula="1")],
                ),
                SensorConfig(
                    unique_id="energy_cost",
                    name="Energy Cost Estimator",
                    entity_id="sensor.energy_cost_estimator",
                    formulas=[FormulaConfig(id="energy_cost", formula="1")],
                ),
            ],
        )
        await sensor_set.async_modify(prep_mod)

        # Now apply Phase 3: Bulk entity ID changes
        entity_id_changes = {
            # Sensor entity IDs
            "sensor.total_power_consumption": "sensor.new_total_power_consumption",
            "sensor.power_efficiency": "sensor.new_power_efficiency",
            "sensor.local_sensor": "sensor.new_local_sensor",
            "sensor.complex_calculation": "sensor.new_complex_calculation",
            "sensor.power_factor_calculator": "sensor.new_power_factor_calculator",
            "sensor.energy_cost_estimator": "sensor.new_energy_cost_estimator",
            # Variable entity IDs (used in formulas)
            "sensor.house_power_meter": "sensor.new_house_power_meter",
            "sensor.house_voltage": "sensor.new_house_voltage",
            "sensor.local_temperature": "sensor.new_local_temperature",
            "sensor.house_current": "sensor.new_house_current",
        }

        # Add voltage monitor back with new entity ID
        restored_voltage_monitor = SensorConfig(
            unique_id="voltage_monitor",
            name="Voltage Monitor (Restored)",
            entity_id="sensor.new_voltage_monitor",
            formulas=[
                FormulaConfig(
                    id="voltage_monitor",
                    formula='state("main_voltage")',
                    unit_of_measurement="V",
                    device_class="voltage",
                    state_class="measurement",
                    attributes={"source_entity": "main_voltage", "monitor_type": "direct_passthrough", "restored": True},
                )
            ],
        )

        # Update complex calculation formula
        updated_complex = SensorConfig(
            unique_id="complex_calculation",
            name="Complex Multi-Formula Sensor",
            entity_id="sensor.new_complex_calculation",
            formulas=[
                FormulaConfig(
                    id="complex_calculation",  # Main formula - determines sensor state
                    formula='state("main_power") * 0.9',  # Changed from 0.8
                    unit_of_measurement="W",
                    device_class="power",
                    state_class="measurement",
                    attributes={
                        "phase": "primary",
                        "multiplier": 0.9,
                    },
                ),
                # Attribute formula
                FormulaConfig(
                    id="voltage_percentage",
                    formula='state("main_voltage") / 120 * 100',
                    variables={"reference_voltage": 120},
                    unit_of_measurement="%",
                    attributes={"reference": "120V"},
                ),
            ],
        )

        # Update global settings with new entity IDs
        new_global_settings = {
            "variables": {
                "main_power": "sensor.new_house_power_meter",
                "main_voltage": "sensor.new_house_voltage",
                "efficiency_factor": 0.92,
                "new_multiplier": 1.1,
            },
            "device_identifier": "test_device:modify_123",
        }

        modification = SensorSetModification(
            entity_id_changes=entity_id_changes,
            add_sensors=[restored_voltage_monitor],
            update_sensors=[updated_complex],
            global_settings=new_global_settings,
        )

        result = await sensor_set.async_modify(modification)

        # Verify bulk entity ID changes
        assert result["entity_ids_changed"] == 10
        assert result["sensors_added"] == 1  # voltage_monitor restored
        assert result["sensors_updated"] == 1  # complex_calculation updated

        # Verify entity ID changes were applied correctly
        _total_power = sensor_set.get_sensor("total_power")
        # Note: The actual entity ID change would be reflected in global settings
        # which would be used when formulas are evaluated

        # Check that energy_cost sensor was kept (added in Phase 2)
        energy_cost = sensor_set.get_sensor("energy_cost")
        assert energy_cost is not None
        assert energy_cost.entity_id == "sensor.new_energy_cost_estimator"  # Entity ID was changed

        # Check that voltage_monitor was restored (added back)
        voltage_monitor = sensor_set.get_sensor("voltage_monitor")
        assert voltage_monitor is not None
        assert voltage_monitor.entity_id == "sensor.new_voltage_monitor"
        assert voltage_monitor.name == "Voltage Monitor (Restored)"

        # Check global settings were updated
        data = sensor_set.storage_manager._ensure_loaded()
        global_settings = data["sensor_sets"][sensor_set.sensor_set_id]["global_settings"]
        assert global_settings["variables"]["main_power"] == "sensor.new_house_power_meter"
        assert global_settings["variables"]["main_voltage"] == "sensor.new_house_voltage"

    @patch("homeassistant.helpers.entity_registry.async_get")
    async def test_phase4_return_to_origin(self, mock_er_async_get, comprehensive_sensor_set, load_yaml_fixture):
        """Test Phase 4: Return to original state with some changes."""
        # Setup entity registry mock
        mock_entity_registry = MagicMock()
        mock_entity_registry.async_get.return_value = None  # No existing entity
        mock_entity_registry.async_update_entity = MagicMock()
        mock_er_async_get.return_value = mock_entity_registry

        sensor_set = comprehensive_sensor_set

        # Apply simplified Phase 2 and 3 changes first
        # (In real test, this would be the accumulated state from previous phases)
        prep_mod = SensorSetModification(
            remove_sensors=["voltage_monitor"],
            add_sensors=[
                SensorConfig(
                    unique_id="new_power_factor",
                    name="Power Factor Calculator",
                    entity_id="sensor.new_power_factor_calculator",
                    formulas=[FormulaConfig(id="new_power_factor", formula="1")],
                ),
                SensorConfig(
                    unique_id="energy_cost",
                    name="Energy Cost Estimator",
                    entity_id="sensor.new_energy_cost_estimator",
                    formulas=[FormulaConfig(id="energy_cost", formula="1")],
                ),
            ],
        )
        await sensor_set.async_modify(prep_mod)

        # Now return to origin-like state
        entity_id_changes = {
            # Revert entity IDs back to original
            "sensor.new_total_power_consumption": "sensor.total_power_consumption",
            "sensor.new_power_efficiency": "sensor.power_efficiency",
            "sensor.new_local_sensor": "sensor.local_sensor",
            "sensor.new_complex_calculation": "sensor.complex_calculation",
            "sensor.new_energy_cost_estimator": "sensor.energy_cost_estimator",
            # Revert variable entity IDs
            "sensor.new_house_power_meter": "sensor.house_power_meter",
            "sensor.new_house_voltage": "sensor.house_voltage",
            "sensor.new_local_temperature": "sensor.local_temperature",
        }

        # Restore voltage monitor to original state
        restored_voltage_monitor = SensorConfig(
            unique_id="voltage_monitor",
            name="Voltage Monitor",
            entity_id="sensor.voltage_monitor",
            formulas=[
                FormulaConfig(
                    id="voltage_monitor",
                    formula='state("main_voltage")',
                    unit_of_measurement="V",
                    device_class="voltage",
                    state_class="measurement",
                    attributes={"source_entity": "main_voltage", "monitor_type": "direct_passthrough"},
                )
            ],
        )

        # Update total power back to original formula
        original_total_power = SensorConfig(
            unique_id="total_power",
            name="Total Power Consumption",
            entity_id="sensor.total_power_consumption",
            formulas=[
                FormulaConfig(
                    id="total_power",
                    formula='state("main_power") * efficiency_factor',
                    unit_of_measurement="W",
                    device_class="power",
                    state_class="measurement",
                    attributes={
                        "source": "main_power",
                        "efficiency": "efficiency_factor",
                        "calculation_type": "simple_multiplication",
                    },
                )
            ],
        )

        # Update local sensor back to original offset
        original_local_sensor = SensorConfig(
            unique_id="local_sensor",
            name="Local Sensor (No Globals)",
            entity_id="sensor.local_sensor",
            formulas=[
                FormulaConfig(
                    id="local_sensor",
                    formula='state("local_var") + 10',
                    variables={"local_var": "sensor.local_temperature"},
                    unit_of_measurement="°C",
                    device_class="temperature",
                    state_class="measurement",
                    attributes={"offset": 10, "source": "local_temperature"},
                )
            ],
        )

        # Restore original global settings
        original_global_settings = {
            "variables": {
                "main_power": "sensor.house_power_meter",
                "main_voltage": "sensor.house_voltage",
                "efficiency_factor": 0.95,  # Back to original
            },
            "device_identifier": "test_device:modify_123",
        }

        modification = SensorSetModification(
            entity_id_changes=entity_id_changes,
            remove_sensors=["new_power_factor"],  # Remove one of the added sensors
            add_sensors=[restored_voltage_monitor],
            update_sensors=[original_total_power, original_local_sensor],
            global_settings=original_global_settings,
        )

        result = await sensor_set.async_modify(modification)

        # Verify return to origin
        assert result["entity_ids_changed"] == 8
        assert result["sensors_removed"] == 1  # new_power_factor removed
        assert result["sensors_added"] == 1  # voltage_monitor restored
        assert result["sensors_updated"] == 2  # total_power, local_sensor
        assert result["global_settings_updated"] is True

        # Verify final state is close to original
        sensors = sensor_set.list_sensors()
        sensor_ids = [s.unique_id for s in sensors]

        # Should have 6 sensors (5 original + 1 energy_cost kept)
        assert len(sensors) == 6
        assert "voltage_monitor" in sensor_ids  # Restored
        assert "new_power_factor" not in sensor_ids  # Removed
        assert "energy_cost" in sensor_ids  # Kept from phase 2

        # Verify sensors are back to original-like state
        total_power = sensor_set.get_sensor("total_power")
        assert total_power.name == "Total Power Consumption"
        assert total_power.entity_id == "sensor.total_power_consumption"
        assert "new_multiplier" not in total_power.formulas[0].formula
        assert total_power.formulas[0].attributes["calculation_type"] == "simple_multiplication"

        local_sensor = sensor_set.get_sensor("local_sensor")
        assert local_sensor.formulas[0].attributes["offset"] == 10
        assert local_sensor.formulas[0].variables["local_var"] == "sensor.local_temperature"

        voltage_monitor = sensor_set.get_sensor("voltage_monitor")
        assert voltage_monitor.entity_id == "sensor.voltage_monitor"
        assert "restored" not in voltage_monitor.formulas[0].attributes

    @patch("homeassistant.helpers.entity_registry.async_get")
    async def test_cache_invalidation_throughout_phases(self, mock_er_async_get, comprehensive_sensor_set):
        """Test that formula caches are properly invalidated throughout all phases."""
        # Setup entity registry mock
        mock_entity_registry = MagicMock()
        mock_entity_registry.async_get.return_value = None  # No existing entity
        mock_entity_registry.async_update_entity = MagicMock()
        mock_er_async_get.return_value = mock_entity_registry

        sensor_set = comprehensive_sensor_set

        # Phase 1: Simple modification
        simple_mod = SensorSetModification(entity_id_changes={"sensor.house_power_meter": "sensor.temp_power_meter"})
        await sensor_set.async_modify(simple_mod)

        # Phase 2: Complex modification
        complex_mod = SensorSetModification(
            add_sensors=[
                SensorConfig(
                    unique_id="temp_sensor", name="Temp Sensor", formulas=[FormulaConfig(id="temp_sensor", formula="1")]
                )
            ],
            remove_sensors=["voltage_monitor"],
            entity_id_changes={"sensor.temp_power_meter": "sensor.final_power_meter"},
        )
        await sensor_set.async_modify(complex_mod)

        # Verify sensors maintain integrity
        sensors = sensor_set.list_sensors()
        assert len(sensors) == 5  # 5 original - 1 removed + 1 added

        # Verify entity ID changes were applied correctly
        _total_power = sensor_set.get_sensor("total_power")
        # Note: The actual entity ID change would be reflected in global settings
        # which would be used when formulas are evaluated

        # Check that temp_sensor was added
        temp_sensor = sensor_set.get_sensor("temp_sensor")
        assert temp_sensor is not None

    @patch("homeassistant.helpers.entity_registry.async_get")
    async def test_validation_across_phases(self, mock_er_async_get, comprehensive_sensor_set):
        """Test validation works correctly across different modification phases."""
        # Setup entity registry mock
        mock_entity_registry = MagicMock()
        mock_entity_registry.async_get.return_value = None  # No existing entity
        mock_entity_registry.async_update_entity = MagicMock()
        mock_er_async_get.return_value = mock_entity_registry

        sensor_set = comprehensive_sensor_set

        # Test 1: Try to add sensor with existing unique_id
        duplicate_sensor = SensorConfig(
            unique_id="total_power",  # Already exists
            name="Duplicate",
            formulas=[FormulaConfig(id="dup", formula="1")],
        )

        with pytest.raises(Exception) as exc_info:
            await sensor_set.async_modify(SensorSetModification(add_sensors=[duplicate_sensor]))
        assert "already exists" in str(exc_info.value)

        # Test 2: Try to remove non-existent sensor
        with pytest.raises(Exception) as exc_info:
            await sensor_set.async_modify(SensorSetModification(remove_sensors=["non_existent"]))
        assert "not found" in str(exc_info.value)

        # Test 3: Try to update non-existent sensor
        missing_sensor = SensorConfig(
            unique_id="missing_sensor", name="Missing", formulas=[FormulaConfig(id="missing", formula="1")]
        )

        with pytest.raises(Exception) as exc_info:
            await sensor_set.async_modify(SensorSetModification(update_sensors=[missing_sensor]))
        assert "not found" in str(exc_info.value)

        # Test 4: Conflicting operations
        conflict_sensor = SensorConfig(
            unique_id="conflict_test", name="Conflict Test", formulas=[FormulaConfig(id="conflict", formula="1")]
        )

        with pytest.raises(Exception) as exc_info:
            await sensor_set.async_modify(
                SensorSetModification(
                    add_sensors=[conflict_sensor],
                    remove_sensors=["conflict_test"],  # Can't add and remove same sensor
                )
            )
        assert "Cannot add and remove same sensors" in str(exc_info.value)


class TestSensorSetModifyValidation:
    """Test that modification validation correctly rejects conflicting changes."""

    @patch("homeassistant.helpers.entity_registry.async_get")
    async def test_valid_modification_succeeds(self, mock_er_async_get, storage_manager_real):
        """Test that a valid modification without conflicts succeeds."""
        # Setup entity registry mock
        mock_entity_registry = MagicMock()
        mock_entity_registry.async_get.return_value = None  # No existing entity
        mock_entity_registry.async_update_entity = MagicMock()
        mock_er_async_get.return_value = mock_entity_registry

        # Load storage first
        await storage_manager_real.async_load()

        # Create a sensor set with global settings
        sensor_set = await storage_manager_real.async_create_sensor_set("test_valid_mod", name="Valid Modification Test")

        # Import initial YAML with global settings
        initial_yaml = """
version: "1.0"
global_settings:
  variables:
    main_power: sensor.house_power_meter
    efficiency_factor: 0.95
  device_identifier: test_device:valid_123

sensors:
  test_sensor:
    name: Test Sensor
    entity_id: sensor.test_sensor
    formula: state("main_power") * efficiency_factor
    unit_of_measurement: W
    device_class: power
    state_class: measurement
"""

        await sensor_set.async_import_yaml(initial_yaml)

        # Valid modification: add a new sensor that uses global variables
        new_sensor = SensorConfig(
            unique_id="new_sensor",
            name="New Sensor",
            entity_id="sensor.new_sensor",
            formulas=[
                FormulaConfig(
                    id="new_sensor",
                    formula='state("main_power") * 2',
                    unit_of_measurement="W",
                    device_class="power",
                    state_class="measurement",
                )
            ],
        )

        modification = SensorSetModification(add_sensors=[new_sensor])

        # This should succeed without conflicts
        result = await sensor_set.async_modify(modification)

        assert result["sensors_added"] == 1
        assert result["sensors_removed"] == 0
        assert result["sensors_updated"] == 0

        # Verify the sensor was added
        sensors = sensor_set.list_sensors()
        assert len(sensors) == 2
        assert any(s.unique_id == "new_sensor" for s in sensors)

    @patch("homeassistant.helpers.entity_registry.async_get")
    async def test_conflicting_global_variable_rejected(self, mock_er_async_get, storage_manager_real):
        """Test that conflicting global variable changes are rejected."""
        # Setup entity registry mock
        mock_entity_registry = MagicMock()
        mock_entity_registry.async_get.return_value = None  # No existing entity
        mock_entity_registry.async_update_entity = MagicMock()
        mock_er_async_get.return_value = mock_entity_registry

        # Load storage first
        await storage_manager_real.async_load()

        # Create a sensor set with global settings
        sensor_set = await storage_manager_real.async_create_sensor_set("test_conflict", name="Conflict Test")

        # Import initial YAML with global settings
        initial_yaml = """
version: "1.0"
global_settings:
  variables:
    main_power: sensor.house_power_meter
    efficiency_factor: 0.95
  device_identifier: test_device:conflict_123

sensors:
  test_sensor:
    name: Test Sensor
    entity_id: sensor.test_sensor
    formula: state("main_power") * efficiency_factor
    variables:
      efficiency_factor: 0.95  # Local variable matching global
    unit_of_measurement: W
    device_class: power
    state_class: measurement
"""

        await sensor_set.async_import_yaml(initial_yaml)

        # Invalid modification: change global variable but sensor has conflicting local value
        modification = SensorSetModification(
            global_settings={
                "variables": {
                    "main_power": "sensor.house_power_meter",
                    "efficiency_factor": 0.92,  # Different from local value
                },
                "device_identifier": "test_device:conflict_123",
            }
        )

        # This should be rejected due to conflict
        with pytest.raises(SyntheticSensorsError, match="conflicting variable"):
            await sensor_set.async_modify(modification)

    @patch("homeassistant.helpers.entity_registry.async_get")
    async def test_valid_global_variable_change_succeeds(self, mock_er_async_get, storage_manager_real):
        """Test that valid global variable changes are accepted."""
        # Setup entity registry mock
        mock_entity_registry = MagicMock()
        mock_entity_registry.async_get.return_value = None
        mock_entity_registry.async_update_entity = MagicMock()
        mock_er_async_get.return_value = mock_entity_registry

        await storage_manager_real.async_load()

        # Create initial sensor set
        sensor_set = await storage_manager_real.async_create_sensor_set(
            sensor_set_id="test_global_change", device_identifier="test_device:789"
        )

        # Add sensor with global variable reference
        test_sensor = SensorConfig(
            unique_id="test_sensor",
            name="Test Sensor",
            formulas=[
                FormulaConfig(
                    id="test_sensor",
                    formula="global_var * 2",
                )
            ],
        )

        # First modification: Add sensor and set global variable
        modification1 = SensorSetModification(add_sensors=[test_sensor], global_settings={"variables": {"global_var": 10}})

        result = await sensor_set.async_modify(modification1)
        assert result["global_settings_updated"] is True

        # Second modification: Change global variable value (should succeed)
        modification2 = SensorSetModification(global_settings={"variables": {"global_var": 20}})

        result = await sensor_set.async_modify(modification2)
        assert result["global_settings_updated"] is True


class TestSensorSetFormulaEvaluationAfterModify:
    """Test that formula modifications produce correct structural changes."""

    @pytest.fixture
    def load_yaml_fixture(self):
        """Load a YAML fixture file and return its contents."""

        def _load_yaml_fixture(fixture_name: str) -> str:
            import os

            fixture_path = os.path.join("tests", "yaml_fixtures", fixture_name)
            with open(fixture_path) as f:
                return f.read()

        return _load_yaml_fixture

    @patch("homeassistant.helpers.entity_registry.async_get")
    async def test_formula_modification_structural_changes(self, mock_er_async_get, storage_manager_real, load_yaml_fixture):
        """Test that formula modifications produce correct structural changes."""
        # Setup entity registry mock
        mock_entity_registry = MagicMock()
        mock_entity_registry.async_get.return_value = None
        mock_entity_registry.async_update_entity = MagicMock()
        mock_er_async_get.return_value = mock_entity_registry

        await storage_manager_real.async_load()

        # Load initial state from YAML fixture
        before_yaml = load_yaml_fixture("formula_evaluation_before.yaml")
        sensor_set_id = await storage_manager_real.async_from_yaml(
            yaml_content=before_yaml, sensor_set_id="formula_eval_test", device_identifier="test_device:eval_123"
        )
        sensor_set = storage_manager_real.get_sensor_set(sensor_set_id)

        # Verify initial state
        assert sensor_set.sensor_count == 5
        assert sensor_set.get_sensor("simple_math") is not None
        assert sensor_set.get_sensor("power_calculation") is not None
        assert sensor_set.get_sensor("cost_calculator") is not None
        assert sensor_set.get_sensor("voltage_ratio") is not None
        assert sensor_set.get_sensor("complex_calculation") is not None

        # Check initial formulas
        simple_math = sensor_set.get_sensor("simple_math")
        assert simple_math.formulas[0].formula == "10 + 5 * 2"

        power_calc = sensor_set.get_sensor("power_calculation")
        assert power_calc.formulas[0].formula == "base_power * efficiency_factor"

        # Check initial global settings
        initial_yaml = sensor_set.export_yaml()
        import yaml

        initial_data = yaml.safe_load(initial_yaml)
        assert initial_data["global_settings"]["variables"]["efficiency_factor"] == 0.95
        assert initial_data["global_settings"]["variables"]["tax_rate"] == 0.08

        # Load the "after" configuration
        after_yaml = load_yaml_fixture("formula_evaluation_after.yaml")
        after_data = yaml.safe_load(after_yaml)

        # Create modification from the differences
        from ha_synthetic_sensors.config_manager import ConfigManager

        config_manager = ConfigManager(storage_manager_real.hass)
        after_config = config_manager.load_from_dict(after_data)

        # Apply the modification
        modification = SensorSetModification(
            update_sensors=after_config.sensors[:-1],  # All except the new sensor
            add_sensors=[after_config.sensors[-1]],  # The new energy_efficiency sensor
            global_settings=after_config.global_settings,
        )

        result = await sensor_set.async_modify(modification)

        # Verify modification was successful
        assert result["sensors_updated"] == 5  # Updated all existing sensors
        assert result["sensors_added"] == 1  # Added energy_efficiency sensor
        assert result["global_settings_updated"] is True

        # Verify structural changes
        assert sensor_set.sensor_count == 6  # 5 original + 1 new

        # Check that formulas were updated
        simple_math_after = sensor_set.get_sensor("simple_math")
        assert simple_math_after.formulas[0].formula == "20 + 3 * 4"
        assert simple_math_after.name == "Simple Math Sensor (Updated)"

        power_calc_after = sensor_set.get_sensor("power_calculation")
        assert power_calc_after.formulas[0].formula == "base_power * efficiency_factor * new_multiplier"

        cost_calc_after = sensor_set.get_sensor("cost_calculator")
        assert "fixed_fee" in cost_calc_after.formulas[0].formula
        # Check that local variables were updated
        cost_vars = cost_calc_after.formulas[0].variables
        assert cost_vars["rate_per_kwh"] == 0.18
        assert cost_vars["fixed_fee"] == 2.50

        voltage_ratio_after = sensor_set.get_sensor("voltage_ratio")
        assert "adjustment_factor" in voltage_ratio_after.formulas[0].formula
        voltage_vars = voltage_ratio_after.formulas[0].variables
        assert voltage_vars["adjustment_factor"] == 1.05

        # Check new sensor was added
        energy_efficiency = sensor_set.get_sensor("energy_efficiency")
        assert energy_efficiency is not None
        assert energy_efficiency.name == "Energy Efficiency Rating"
        assert energy_efficiency.formulas[0].formula == "(base_power * efficiency_factor) / theoretical_max * 100"

        # Check that new attribute was added to complex_calculation
        complex_calc_after = sensor_set.get_sensor("complex_calculation")
        attribute_formulas = [f for f in complex_calc_after.formulas if f.id.endswith("_new_metric")]
        assert len(attribute_formulas) == 1
        assert attribute_formulas[0].formula == "base_power / base_voltage"

        # Verify global settings were updated
        final_yaml = sensor_set.export_yaml()
        final_data = yaml.safe_load(final_yaml)

        assert final_data["global_settings"]["variables"]["efficiency_factor"] == 0.90
        assert final_data["global_settings"]["variables"]["tax_rate"] == 0.10
        assert final_data["global_settings"]["variables"]["new_multiplier"] == 1.2

        # Verify entity index was updated correctly
        entity_stats = sensor_set.get_entity_index_stats()
        # Should track entities referenced in formulas and variables
        assert entity_stats["total_entities"] > 0
        assert sensor_set.is_entity_tracked("sensor.power_meter")
        assert sensor_set.is_entity_tracked("sensor.voltage_meter")
        assert sensor_set.is_entity_tracked("sensor.reactive_power")

    @patch("homeassistant.helpers.entity_registry.async_get")
    async def test_formula_evaluation_with_simple_math(self, mock_er_async_get, storage_manager_real):
        """Test simple formula evaluation to verify the evaluator works."""
        # Setup entity registry mock
        mock_entity_registry = MagicMock()
        mock_entity_registry.async_get.return_value = None
        mock_entity_registry.async_update_entity = MagicMock()
        mock_er_async_get.return_value = mock_entity_registry

        await storage_manager_real.async_load()

        # Create a simple sensor set with basic math
        sensor_set = await storage_manager_real.async_create_sensor_set(
            sensor_set_id="simple_eval_test", device_identifier="test_device:simple_123"
        )

        # Add a sensor with simple math
        from ha_synthetic_sensors.config_manager import FormulaConfig, SensorConfig

        simple_sensor = SensorConfig(
            unique_id="simple_math_test",
            name="Simple Math Test",
            formulas=[
                FormulaConfig(
                    id="simple_math_test",
                    formula="10 + 5 * 2",
                    unit_of_measurement="units",
                )
            ],
        )

        await sensor_set.async_add_sensor(simple_sensor)

        # Test evaluation using the evaluator
        from ha_synthetic_sensors.evaluator import Evaluator

        evaluator = Evaluator(storage_manager_real.hass)

        # Get the sensor and evaluate its formula
        stored_sensor = sensor_set.get_sensor("simple_math_test")
        result = evaluator.evaluate_formula(stored_sensor.formulas[0], {})

        assert result["success"] is True
        assert result["value"] == 20.0

        # Now modify the formula and test again
        updated_sensor = SensorConfig(
            unique_id="simple_math_test",
            name="Simple Math Test Updated",
            formulas=[
                FormulaConfig(
                    id="simple_math_test",
                    formula="20 + 3 * 4",  # Should equal 32
                    unit_of_measurement="units",
                )
            ],
        )

        modification = SensorSetModification(update_sensors=[updated_sensor])
        mod_result = await sensor_set.async_modify(modification)
        assert mod_result["sensors_updated"] == 1

        # NOTE: In real integration usage, cache clearing is handled by higher-level
        # components (ServiceLayer, SensorManager) that orchestrate the modification.
        # Here we clear manually since we're testing async_modify in isolation.
        evaluator.clear_cache()

        # Test the updated formula
        updated_stored_sensor = sensor_set.get_sensor("simple_math_test")
        updated_result = evaluator.evaluate_formula(updated_stored_sensor.formulas[0], {})

        assert updated_result["success"] is True
        assert updated_result["value"] == 32.0
        assert updated_stored_sensor.name == "Simple Math Test Updated"

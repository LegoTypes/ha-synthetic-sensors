"""Tests for SensorSet bulk modification functionality using comprehensive YAML fixtures."""

from unittest.mock import MagicMock, patch

import pytest

from ha_synthetic_sensors.config_manager import FormulaConfig, SensorConfig
from ha_synthetic_sensors.exceptions import SyntheticSensorsError
from ha_synthetic_sensors.sensor_set import SensorSetModification


class TestSensorSetModifyComprehensive:
    """Test SensorSet bulk modification with comprehensive multi-phase YAML scenarios."""

    @pytest.fixture
    def load_yaml_fixture(self):
        """Load a YAML fixture file and return its contents."""

        def _load_yaml_fixture(fixture_name: str) -> str:
            import os

            fixture_path = os.path.join("tests", "yaml_fixtures", fixture_name)
            with open(fixture_path) as f:
                return f.read()

        return _load_yaml_fixture

    @pytest.fixture
    async def comprehensive_sensor_set(self, storage_manager_real, load_yaml_fixture):
        """Create a comprehensive sensor set from Phase 1 YAML."""
        await storage_manager_real.async_load()

        # Load Phase 1 YAML
        phase1_yaml = load_yaml_fixture("modify_test_phase1_initial.yaml")

        # Create sensor set from YAML
        sensor_set_id = await storage_manager_real.async_from_yaml(
            yaml_content=phase1_yaml, sensor_set_id="comprehensive_modify_test", device_identifier="test_device:modify_123"
        )

        return storage_manager_real.get_sensor_set(sensor_set_id)

    async def test_phase1_initial_state(self, comprehensive_sensor_set):
        """Test Phase 1: Verify initial comprehensive sensor set state."""
        sensor_set = comprehensive_sensor_set

        # Verify sensor set metadata
        assert sensor_set.sensor_set_id == "comprehensive_modify_test"
        assert sensor_set.metadata.device_identifier == "test_device:modify_123"
        # Note: Name is auto-generated by storage manager

        # Verify all initial sensors are present
        sensors = sensor_set.list_sensors()
        sensor_ids = [s.unique_id for s in sensors]

        expected_sensors = ["total_power", "power_efficiency", "voltage_monitor", "local_sensor", "complex_calculation"]

        assert len(sensors) == 5
        for expected_id in expected_sensors:
            assert expected_id in sensor_ids

            # Verify global settings usage
        total_power = sensor_set.get_sensor("total_power")
        assert total_power is not None
        assert "efficiency_factor" in total_power.formulas[0].formula
        # Check for attribute formulas (formulas beyond the main one)
        assert len(total_power.formulas) >= 1  # At least the main formula

        # Verify local sensor (no globals)
        local_sensor = sensor_set.get_sensor("local_sensor")
        assert local_sensor is not None
        assert local_sensor.formulas[0].variables["local_var"] == "sensor.local_temperature"
        # Check for attribute formulas
        assert len(local_sensor.formulas) >= 1  # At least the main formula

        # Verify complex calculation sensor
        complex_sensor = sensor_set.get_sensor("complex_calculation")
        assert complex_sensor is not None
        assert len(complex_sensor.formulas) >= 1  # At least the main formula
        assert "0.8" in complex_sensor.formulas[0].formula

    @patch("homeassistant.helpers.entity_registry.async_get")
    async def test_phase2_add_remove_modify(self, mock_er_async_get, comprehensive_sensor_set, load_yaml_fixture):
        """Test Phase 2: Add sensors, remove voltage_monitor, modify formulas."""
        # Setup entity registry mock
        mock_entity_registry = MagicMock()
        mock_entity_registry.async_get.return_value = None  # No existing entity
        mock_entity_registry.async_update_entity = MagicMock()
        mock_er_async_get.return_value = mock_entity_registry

        sensor_set = comprehensive_sensor_set

        # Load Phase 2 YAML to understand target state
        _phase2_yaml = load_yaml_fixture("modify_test_phase2_add_remove.yaml")

        # Create modifications to transform from Phase 1 to Phase 2

        # 1. Remove voltage_monitor
        remove_sensors = ["voltage_monitor"]

        # 2. Update existing sensors with new formulas/attributes
        updated_total_power = SensorConfig(
            unique_id="total_power",
            name="Total Power Consumption (Updated)",
            entity_id="sensor.total_power_consumption",
            formulas=[
                FormulaConfig(
                    id="total_power",
                    formula='state("main_power") * efficiency_factor * new_multiplier',
                    unit_of_measurement="W",
                    device_class="power",
                    state_class="measurement",
                )
            ],
        )

        updated_local_sensor = SensorConfig(
            unique_id="local_sensor",
            name="Local Sensor (No Globals)",
            entity_id="sensor.local_sensor",
            formulas=[
                FormulaConfig(
                    id="local_sensor",
                    formula='state("local_var") + 15',
                    variables={"local_var": "sensor.local_temperature"},
                    unit_of_measurement="°C",
                    device_class="temperature",
                    state_class="measurement",
                )
            ],
        )

        # 3. Add new sensors
        new_power_factor = SensorConfig(
            unique_id="new_power_factor",
            name="Power Factor Calculator",
            entity_id="sensor.power_factor_calculator",
            formulas=[
                FormulaConfig(
                    id="new_power_factor",
                    formula='state("main_power") / (state("main_voltage") * state("current_var"))',
                    variables={"current_var": "sensor.house_current"},
                    unit_of_measurement="",
                    state_class="measurement",
                )
            ],
        )

        new_energy_cost = SensorConfig(
            unique_id="energy_cost",
            name="Energy Cost Estimator",
            entity_id="sensor.energy_cost_estimator",
            formulas=[
                FormulaConfig(
                    id="energy_cost",
                    formula='(state("main_power") / 1000) * efficiency_factor * cost_per_kwh',
                    variables={"cost_per_kwh": 0.12},
                    unit_of_measurement="$/hr",
                    state_class="measurement",
                )
            ],
        )

        # 4. Update global settings
        new_global_settings = {
            "variables": {
                "main_power": "sensor.house_power_meter",
                "main_voltage": "sensor.house_voltage",
                "efficiency_factor": 0.92,  # Changed from 0.95
                "new_multiplier": 1.1,  # Added new variable
            },
            "device_identifier": "test_device:modify_123",
        }

        # Apply all modifications in one bulk operation
        modification = SensorSetModification(
            remove_sensors=remove_sensors,
            update_sensors=[updated_total_power, updated_local_sensor],
            add_sensors=[new_power_factor, new_energy_cost],
            global_settings=new_global_settings,
        )

        # Apply all modifications in one bulk operation
        result = await sensor_set.async_modify(modification)

        # Verify modification results
        assert result["sensors_removed"] == 1
        assert result["sensors_updated"] == 2
        assert result["sensors_added"] == 2
        assert result["global_settings_updated"] is True

        # Verify final state
        sensors = sensor_set.list_sensors()
        sensor_ids = [s.unique_id for s in sensors]

        # Should have 6 sensors now (5 original - 1 removed + 2 added)
        assert len(sensors) == 6
        assert "voltage_monitor" not in sensor_ids  # Removed
        assert "new_power_factor" in sensor_ids  # Added
        assert "energy_cost" in sensor_ids  # Added

        # Verify updated sensors
        updated_total = sensor_set.get_sensor("total_power")
        assert updated_total.name == "Total Power Consumption (Updated)"
        assert "new_multiplier" in updated_total.formulas[0].formula

        updated_local = sensor_set.get_sensor("local_sensor")
        assert "15" in updated_local.formulas[0].formula

    @patch("homeassistant.helpers.entity_registry.async_get")
    async def test_phase3_bulk_entity_changes(self, mock_er_async_get, comprehensive_sensor_set, load_yaml_fixture):
        """Test Phase 3: Bulk entity ID changes across all sensors."""
        # Setup entity registry mock
        mock_entity_registry = MagicMock()
        mock_entity_registry.async_get.return_value = None  # No existing entity
        mock_entity_registry.async_update_entity = MagicMock()
        mock_er_async_get.return_value = mock_entity_registry

        sensor_set = comprehensive_sensor_set

        # Apply Phase 2 changes first (simulate accumulated state)
        prep_mod = SensorSetModification(
            remove_sensors=["voltage_monitor"],
            add_sensors=[
                SensorConfig(
                    unique_id="new_power_factor",
                    name="Power Factor Calculator",
                    entity_id="sensor.power_factor_calculator",
                    formulas=[FormulaConfig(id="new_power_factor", formula="1")],
                ),
                SensorConfig(
                    unique_id="energy_cost",
                    name="Energy Cost Estimator",
                    entity_id="sensor.energy_cost_estimator",
                    formulas=[FormulaConfig(id="energy_cost", formula="1")],
                ),
            ],
        )
        await sensor_set.async_modify(prep_mod)

        # Now apply Phase 3: Bulk entity ID changes
        entity_id_changes = {
            # Sensor entity IDs
            "sensor.total_power_consumption": "sensor.new_total_power_consumption",
            "sensor.power_efficiency": "sensor.new_power_efficiency",
            "sensor.local_sensor": "sensor.new_local_sensor",
            "sensor.complex_calculation": "sensor.new_complex_calculation",
            "sensor.power_factor_calculator": "sensor.new_power_factor_calculator",
            "sensor.energy_cost_estimator": "sensor.new_energy_cost_estimator",
            # Variable entity IDs (used in formulas)
            "sensor.house_power_meter": "sensor.new_house_power_meter",
            "sensor.house_voltage": "sensor.new_house_voltage",
            "sensor.local_temperature": "sensor.new_local_temperature",
            "sensor.house_current": "sensor.new_house_current",
        }

        # Add voltage monitor back with new entity ID
        restored_voltage_monitor = SensorConfig(
            unique_id="voltage_monitor",
            name="Voltage Monitor (Restored)",
            entity_id="sensor.new_voltage_monitor",
            formulas=[
                FormulaConfig(
                    id="voltage_monitor",
                    formula='state("main_voltage")',
                    unit_of_measurement="V",
                    device_class="voltage",
                    state_class="measurement",
                    attributes={"source_entity": "main_voltage", "monitor_type": "direct_passthrough", "restored": True},
                )
            ],
        )

        # Update complex calculation formula
        updated_complex = SensorConfig(
            unique_id="complex_calculation",
            name="Complex Multi-Formula Sensor",
            entity_id="sensor.new_complex_calculation",
            formulas=[
                FormulaConfig(
                    id="complex_calculation",  # Main formula - determines sensor state
                    formula='state("main_power") * 0.9',  # Changed from 0.8
                    unit_of_measurement="W",
                    device_class="power",
                    state_class="measurement",
                    attributes={
                        "phase": "primary",
                        "multiplier": 0.9,
                    },
                ),
                # Attribute formula
                FormulaConfig(
                    id="voltage_percentage",
                    formula='state("main_voltage") / 120 * 100',
                    variables={"reference_voltage": 120},
                    unit_of_measurement="%",
                    attributes={"reference": "120V"},
                ),
            ],
        )

        # Update global settings with new entity IDs
        new_global_settings = {
            "variables": {
                "main_power": "sensor.new_house_power_meter",
                "main_voltage": "sensor.new_house_voltage",
                "efficiency_factor": 0.92,
                "new_multiplier": 1.1,
            },
            "device_identifier": "test_device:modify_123",
        }

        modification = SensorSetModification(
            entity_id_changes=entity_id_changes,
            add_sensors=[restored_voltage_monitor],
            update_sensors=[updated_complex],
            global_settings=new_global_settings,
        )

        result = await sensor_set.async_modify(modification)

        # Verify bulk entity ID changes
        assert result["entity_ids_changed"] == 10
        assert result["sensors_added"] == 1  # voltage_monitor restored
        assert result["sensors_updated"] == 1  # complex_calculation updated

        # Verify entity ID changes were applied correctly
        _total_power = sensor_set.get_sensor("total_power")
        # Note: The actual entity ID change would be reflected in global settings
        # which would be used when formulas are evaluated

        # Check that energy_cost sensor was kept (added in Phase 2)
        energy_cost = sensor_set.get_sensor("energy_cost")
        assert energy_cost is not None
        assert energy_cost.entity_id == "sensor.new_energy_cost_estimator"  # Entity ID was changed

        # Check that voltage_monitor was restored (added back)
        voltage_monitor = sensor_set.get_sensor("voltage_monitor")
        assert voltage_monitor is not None
        assert voltage_monitor.entity_id == "sensor.new_voltage_monitor"
        assert voltage_monitor.name == "Voltage Monitor (Restored)"

        # Check global settings were updated
        data = sensor_set.storage_manager._ensure_loaded()
        global_settings = data["sensor_sets"][sensor_set.sensor_set_id]["global_settings"]
        assert global_settings["variables"]["main_power"] == "sensor.new_house_power_meter"
        assert global_settings["variables"]["main_voltage"] == "sensor.new_house_voltage"

    @patch("homeassistant.helpers.entity_registry.async_get")
    async def test_phase4_return_to_origin(self, mock_er_async_get, comprehensive_sensor_set, load_yaml_fixture):
        """Test Phase 4: Return to original state with some changes."""
        # Setup entity registry mock
        mock_entity_registry = MagicMock()
        mock_entity_registry.async_get.return_value = None  # No existing entity
        mock_entity_registry.async_update_entity = MagicMock()
        mock_er_async_get.return_value = mock_entity_registry

        sensor_set = comprehensive_sensor_set

        # Apply simplified Phase 2 and 3 changes first
        # (In real test, this would be the accumulated state from previous phases)
        prep_mod = SensorSetModification(
            remove_sensors=["voltage_monitor"],
            add_sensors=[
                SensorConfig(
                    unique_id="new_power_factor",
                    name="Power Factor Calculator",
                    entity_id="sensor.new_power_factor_calculator",
                    formulas=[FormulaConfig(id="new_power_factor", formula="1")],
                ),
                SensorConfig(
                    unique_id="energy_cost",
                    name="Energy Cost Estimator",
                    entity_id="sensor.new_energy_cost_estimator",
                    formulas=[FormulaConfig(id="energy_cost", formula="1")],
                ),
            ],
        )
        await sensor_set.async_modify(prep_mod)

        # Now return to origin-like state
        entity_id_changes = {
            # Revert entity IDs back to original
            "sensor.new_total_power_consumption": "sensor.total_power_consumption",
            "sensor.new_power_efficiency": "sensor.power_efficiency",
            "sensor.new_local_sensor": "sensor.local_sensor",
            "sensor.new_complex_calculation": "sensor.complex_calculation",
            "sensor.new_energy_cost_estimator": "sensor.energy_cost_estimator",
            # Revert variable entity IDs
            "sensor.new_house_power_meter": "sensor.house_power_meter",
            "sensor.new_house_voltage": "sensor.house_voltage",
            "sensor.new_local_temperature": "sensor.local_temperature",
        }

        # Restore voltage monitor to original state
        restored_voltage_monitor = SensorConfig(
            unique_id="voltage_monitor",
            name="Voltage Monitor",
            entity_id="sensor.voltage_monitor",
            formulas=[
                FormulaConfig(
                    id="voltage_monitor",
                    formula='state("main_voltage")',
                    unit_of_measurement="V",
                    device_class="voltage",
                    state_class="measurement",
                    attributes={"source_entity": "main_voltage", "monitor_type": "direct_passthrough"},
                )
            ],
        )

        # Update total power back to original formula
        original_total_power = SensorConfig(
            unique_id="total_power",
            name="Total Power Consumption",
            entity_id="sensor.total_power_consumption",
            formulas=[
                FormulaConfig(
                    id="total_power",
                    formula='state("main_power") * efficiency_factor',
                    unit_of_measurement="W",
                    device_class="power",
                    state_class="measurement",
                    attributes={
                        "source": "main_power",
                        "efficiency": "efficiency_factor",
                        "calculation_type": "simple_multiplication",
                    },
                )
            ],
        )

        # Update local sensor back to original offset
        original_local_sensor = SensorConfig(
            unique_id="local_sensor",
            name="Local Sensor (No Globals)",
            entity_id="sensor.local_sensor",
            formulas=[
                FormulaConfig(
                    id="local_sensor",
                    formula='state("local_var") + 10',
                    variables={"local_var": "sensor.local_temperature"},
                    unit_of_measurement="°C",
                    device_class="temperature",
                    state_class="measurement",
                    attributes={"offset": 10, "source": "local_temperature"},
                )
            ],
        )

        # Restore original global settings
        original_global_settings = {
            "variables": {
                "main_power": "sensor.house_power_meter",
                "main_voltage": "sensor.house_voltage",
                "efficiency_factor": 0.95,  # Back to original
            },
            "device_identifier": "test_device:modify_123",
        }

        modification = SensorSetModification(
            entity_id_changes=entity_id_changes,
            remove_sensors=["new_power_factor"],  # Remove one of the added sensors
            add_sensors=[restored_voltage_monitor],
            update_sensors=[original_total_power, original_local_sensor],
            global_settings=original_global_settings,
        )

        result = await sensor_set.async_modify(modification)

        # Verify return to origin
        assert result["entity_ids_changed"] == 8
        assert result["sensors_removed"] == 1  # new_power_factor removed
        assert result["sensors_added"] == 1  # voltage_monitor restored
        assert result["sensors_updated"] == 2  # total_power, local_sensor
        assert result["global_settings_updated"] is True

        # Verify final state is close to original
        sensors = sensor_set.list_sensors()
        sensor_ids = [s.unique_id for s in sensors]

        # Should have 6 sensors (5 original + 1 energy_cost kept)
        assert len(sensors) == 6
        assert "voltage_monitor" in sensor_ids  # Restored
        assert "new_power_factor" not in sensor_ids  # Removed
        assert "energy_cost" in sensor_ids  # Kept from phase 2

        # Verify sensors are back to original-like state
        total_power = sensor_set.get_sensor("total_power")
        assert total_power.name == "Total Power Consumption"
        assert total_power.entity_id == "sensor.total_power_consumption"
        assert "new_multiplier" not in total_power.formulas[0].formula
        assert total_power.formulas[0].attributes["calculation_type"] == "simple_multiplication"

        local_sensor = sensor_set.get_sensor("local_sensor")
        assert local_sensor.formulas[0].attributes["offset"] == 10
        assert local_sensor.formulas[0].variables["local_var"] == "sensor.local_temperature"

        voltage_monitor = sensor_set.get_sensor("voltage_monitor")
        assert voltage_monitor.entity_id == "sensor.voltage_monitor"
        assert "restored" not in voltage_monitor.formulas[0].attributes

    @patch("homeassistant.helpers.entity_registry.async_get")
    async def test_cache_invalidation_throughout_phases(self, mock_er_async_get, comprehensive_sensor_set):
        """Test that formula caches are properly invalidated throughout all phases."""
        # Setup entity registry mock
        mock_entity_registry = MagicMock()
        mock_entity_registry.async_get.return_value = None  # No existing entity
        mock_entity_registry.async_update_entity = MagicMock()
        mock_er_async_get.return_value = mock_entity_registry

        sensor_set = comprehensive_sensor_set

        # Phase 1: Simple modification
        simple_mod = SensorSetModification(entity_id_changes={"sensor.house_power_meter": "sensor.temp_power_meter"})
        await sensor_set.async_modify(simple_mod)

        # Phase 2: Complex modification
        complex_mod = SensorSetModification(
            add_sensors=[
                SensorConfig(
                    unique_id="temp_sensor", name="Temp Sensor", formulas=[FormulaConfig(id="temp_sensor", formula="1")]
                )
            ],
            remove_sensors=["voltage_monitor"],
            entity_id_changes={"sensor.temp_power_meter": "sensor.final_power_meter"},
        )
        await sensor_set.async_modify(complex_mod)

        # Verify sensors maintain integrity
        sensors = sensor_set.list_sensors()
        assert len(sensors) == 5  # 5 original - 1 removed + 1 added

        # Verify entity ID changes were applied correctly
        _total_power = sensor_set.get_sensor("total_power")
        # Note: The actual entity ID change would be reflected in global settings
        # which would be used when formulas are evaluated

        # Check that temp_sensor was added
        temp_sensor = sensor_set.get_sensor("temp_sensor")
        assert temp_sensor is not None

    @patch("homeassistant.helpers.entity_registry.async_get")
    async def test_validation_across_phases(self, mock_er_async_get, comprehensive_sensor_set):
        """Test validation works correctly across different modification phases."""
        # Setup entity registry mock
        mock_entity_registry = MagicMock()
        mock_entity_registry.async_get.return_value = None  # No existing entity
        mock_entity_registry.async_update_entity = MagicMock()
        mock_er_async_get.return_value = mock_entity_registry

        sensor_set = comprehensive_sensor_set

        # Test 1: Try to add sensor with existing unique_id
        duplicate_sensor = SensorConfig(
            unique_id="total_power",  # Already exists
            name="Duplicate",
            formulas=[FormulaConfig(id="dup", formula="1")],
        )

        with pytest.raises(Exception) as exc_info:
            await sensor_set.async_modify(SensorSetModification(add_sensors=[duplicate_sensor]))
        assert "already exists" in str(exc_info.value)

        # Test 2: Try to remove non-existent sensor
        with pytest.raises(Exception) as exc_info:
            await sensor_set.async_modify(SensorSetModification(remove_sensors=["non_existent"]))
        assert "not found" in str(exc_info.value)

        # Test 3: Try to update non-existent sensor
        missing_sensor = SensorConfig(
            unique_id="missing_sensor", name="Missing", formulas=[FormulaConfig(id="missing", formula="1")]
        )

        with pytest.raises(Exception) as exc_info:
            await sensor_set.async_modify(SensorSetModification(update_sensors=[missing_sensor]))
        assert "not found" in str(exc_info.value)

        # Test 4: Conflicting operations
        conflict_sensor = SensorConfig(
            unique_id="conflict_test", name="Conflict Test", formulas=[FormulaConfig(id="conflict", formula="1")]
        )

        with pytest.raises(Exception) as exc_info:
            await sensor_set.async_modify(
                SensorSetModification(
                    add_sensors=[conflict_sensor],
                    remove_sensors=["conflict_test"],  # Can't add and remove same sensor
                )
            )
        assert "Cannot add and remove same sensors" in str(exc_info.value)


class TestSensorSetModifyValidation:
    """Test that modification validation correctly rejects conflicting changes."""

    @patch("homeassistant.helpers.entity_registry.async_get")
    async def test_valid_modification_succeeds(self, mock_er_async_get, storage_manager_real):
        """Test that a valid modification without conflicts succeeds."""
        # Setup entity registry mock
        mock_entity_registry = MagicMock()
        mock_entity_registry.async_get.return_value = None  # No existing entity
        mock_entity_registry.async_update_entity = MagicMock()
        mock_er_async_get.return_value = mock_entity_registry

        # Load storage first
        await storage_manager_real.async_load()

        # Create a sensor set with global settings
        sensor_set = await storage_manager_real.async_create_sensor_set("test_valid_mod", name="Valid Modification Test")

        # Import initial YAML with global settings
        initial_yaml = """
version: "1.0"
global_settings:
  variables:
    main_power: sensor.house_power_meter
    efficiency_factor: 0.95
  device_identifier: test_device:valid_123

sensors:
  test_sensor:
    name: Test Sensor
    entity_id: sensor.test_sensor
    formula: state("main_power") * efficiency_factor
    unit_of_measurement: W
    device_class: power
    state_class: measurement
"""

        await sensor_set.async_import_yaml(initial_yaml)

        # Valid modification: add a new sensor that uses global variables
        new_sensor = SensorConfig(
            unique_id="new_sensor",
            name="New Sensor",
            entity_id="sensor.new_sensor",
            formulas=[
                FormulaConfig(
                    id="new_sensor",
                    formula='state("main_power") * 2',
                    unit_of_measurement="W",
                    device_class="power",
                    state_class="measurement",
                )
            ],
        )

        modification = SensorSetModification(add_sensors=[new_sensor])

        # This should succeed without conflicts
        result = await sensor_set.async_modify(modification)

        assert result["sensors_added"] == 1
        assert result["sensors_removed"] == 0
        assert result["sensors_updated"] == 0

        # Verify the sensor was added
        sensors = sensor_set.list_sensors()
        assert len(sensors) == 2
        assert any(s.unique_id == "new_sensor" for s in sensors)

    @patch("homeassistant.helpers.entity_registry.async_get")
    async def test_conflicting_global_variable_rejected(self, mock_er_async_get, storage_manager_real):
        """Test that conflicting global variable changes are rejected."""
        # Setup entity registry mock
        mock_entity_registry = MagicMock()
        mock_entity_registry.async_get.return_value = None  # No existing entity
        mock_entity_registry.async_update_entity = MagicMock()
        mock_er_async_get.return_value = mock_entity_registry

        # Load storage first
        await storage_manager_real.async_load()

        # Create a sensor set with global settings
        sensor_set = await storage_manager_real.async_create_sensor_set("test_conflict", name="Conflict Test")

        # Import initial YAML with global settings
        initial_yaml = """
version: "1.0"
global_settings:
  variables:
    main_power: sensor.house_power_meter
    efficiency_factor: 0.95
  device_identifier: test_device:conflict_123

sensors:
  test_sensor:
    name: Test Sensor
    entity_id: sensor.test_sensor
    formula: state("main_power") * efficiency_factor
    variables:
      efficiency_factor: 0.95  # Local variable matching global
    unit_of_measurement: W
    device_class: power
    state_class: measurement
"""

        await sensor_set.async_import_yaml(initial_yaml)

        # Invalid modification: change global variable but sensor has conflicting local value
        modification = SensorSetModification(
            global_settings={
                "variables": {
                    "main_power": "sensor.house_power_meter",
                    "efficiency_factor": 0.92,  # Different from local value
                },
                "device_identifier": "test_device:conflict_123",
            }
        )

        # This should be rejected due to conflict
        with pytest.raises(SyntheticSensorsError, match="conflicting variable"):
            await sensor_set.async_modify(modification)

    @patch("homeassistant.helpers.entity_registry.async_get")
    async def test_valid_global_variable_change_succeeds(self, mock_er_async_get, storage_manager_real):
        """Test that valid global variable changes succeed when no conflicts exist."""
        # Setup entity registry mock
        mock_entity_registry = MagicMock()
        mock_entity_registry.async_get.return_value = None  # No existing entity
        mock_entity_registry.async_update_entity = MagicMock()
        mock_er_async_get.return_value = mock_entity_registry

        # Load storage first
        await storage_manager_real.async_load()

        # Create a sensor set with global settings
        sensor_set = await storage_manager_real.async_create_sensor_set("test_valid_global", name="Valid Global Test")

        # Import initial YAML with global settings
        initial_yaml = """
version: "1.0"
global_settings:
  variables:
    main_power: sensor.house_power_meter
    efficiency_factor: 0.95
  device_identifier: test_device:valid_global_123

sensors:
  test_sensor:
    name: Test Sensor
    entity_id: sensor.test_sensor
    formula: state("main_power") * efficiency_factor
    unit_of_measurement: W
    device_class: power
    state_class: measurement
"""

        await sensor_set.async_import_yaml(initial_yaml)

        # Valid modification: add a new global variable (no conflict possible)
        modification = SensorSetModification(
            global_settings={
                "variables": {
                    "main_power": "sensor.house_power_meter",
                    "efficiency_factor": 0.95,  # Keep existing value
                    "new_multiplier": 1.1,  # Add new variable
                },
                "device_identifier": "test_device:valid_global_123",
            }
        )

        # This should succeed
        result = await sensor_set.async_modify(modification)

        assert result["global_settings_updated"]

        # Verify the global setting was updated
        data = sensor_set.storage_manager._ensure_loaded()
        global_settings = data["sensor_sets"][sensor_set.sensor_set_id]["global_settings"]
        assert global_settings["variables"]["new_multiplier"] == 1.1

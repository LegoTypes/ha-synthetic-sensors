version: "1.0"

global_settings:
  device_identifier: "test_device_123"
  variables:
    # Global variable - numeric value (not quoted)
    global_factor: 1.2

sensors:
  # Keep only novel/compound exception scenarios in this fixture. Basic main-formula
  # and attribute fallback cases and simple mixed handler tests are covered in
  # `alternate_handlers_runtime.yaml` to avoid duplication.

  # 1. Complex computed variable exception handling with nested dependencies
  # Test assertion: computed_adjustment depends on missing sensors; when those are
  # unavailable the computed variable's UNAVAILABLE handler (`backup_calculation`)
  # should be used; nested handlers (e.g., backup_calculation.UNAVAILABLE -> 10)
  # should provide a safe numeric result so overall formula returns a numeric value.
  complex_variable_exceptions:
    name: "Complex Variable Exception Handling"
    formula: "base_power + computed_adjustment + global_factor"
    variables:
      base_power: "sensor.working_entity"  # This should exist
      computed_adjustment:
        formula: "missing_sensor_a + missing_sensor_b"
        alternate_states:
          UNAVAILABLE:
            formula: "backup_calculation"
          UNKNOWN:
            formula: "conservative_estimate"
      backup_calculation:
        formula: "sensor.backup_entity * 0.8"
        alternate_states:
          UNAVAILABLE:
            formula: "10"
      conservative_estimate: "5"
    metadata:
      unit_of_measurement: "W"
      device_class: "power"

  # 2. Circular dependency with exception handling
  # Test assertion: circular dependencies between computed variables should be
  # detected; the system must not infinite-loop and should use the configured
  # alternate handlers (safe_fallback_*) when dependencies cannot be resolved.
  circular_dependency_a:
    name: "Circular Dependency A with Exceptions"
    formula: "circular_var_a + 10"
    variables:
      circular_var_a:
        formula: "circular_dependency_b + missing_entity"
        alternate_states:
          UNAVAILABLE:
            formula: "safe_fallback_a"
          UNKNOWN:
            formula: "estimated_a"
      safe_fallback_a: "30"
      estimated_a: "25"
    metadata:
      unit_of_measurement: "W"
      device_class: "power"

  circular_dependency_b:
  # See circular_dependency_a above; both sensors test mutual recursion handling
  # and that alternate handlers provide safe fallback values when dependencies fail.
    name: "Circular Dependency B with Exceptions"
    formula: "circular_var_b + 20"
    variables:
      circular_var_b:
        formula: "circular_dependency_a + another_missing_entity"
        alternate_states:
          UNAVAILABLE:
            formula: "safe_fallback_b"
          UNKNOWN:
            formula: "estimated_b"
      safe_fallback_b: "40"
      estimated_b: "35"
    metadata:
      unit_of_measurement: "W"
      device_class: "power"

  # 3. Cross-sensor reference with exception handling
  # Test assertion: cross-sensor references that include undefined external sensors
  # should trigger the local alternate handlers (UNAVAILABLE/UNKNOWN) and the
  # sensor should produce the isolated calculation or estimated_cross_value instead
  # of raising a fatal error.
  cross_sensor_exceptions:
    name: "Cross-Sensor Reference Exceptions"
    formula: "local_calculation + complex_variable_exceptions"
    variables:
      local_calculation:
        formula: "main_formula_exceptions + undefined_cross_sensor"
        alternate_states:
          UNAVAILABLE:
            formula: "isolated_calculation"
          UNKNOWN:
            formula: "estimated_cross_value"
      isolated_calculation:
        formula: "known_constant * 2"
        alternate_states:
          UNAVAILABLE:
            formula: "100"
      estimated_cross_value: "75"
      known_constant: "50"
    metadata:
      unit_of_measurement: "W"
      device_class: "power"

  # 4. Multi-level nested exception handling
  # Test assertion: deeply nested computed variables with missing dependencies
  # should resolve through multiple levels of alternate handlers (fallback_level_*
  # and estimated_level_*), returning the top-level fallback/estimate rather than
  # failing the evaluation.
  nested_exceptions:
    name: "Multi-Level Nested Exceptions"
    formula: "level_1"
    variables:
      level_1:
        formula: "level_2 + offset_1"
        alternate_states:
          UNAVAILABLE:
            formula: "fallback_level_1"
          UNKNOWN:
            formula: "estimated_level_1"
      level_2:
        formula: "level_3 + offset_2"
        alternate_states:
          UNAVAILABLE:
            formula: "fallback_level_2"
          UNKNOWN:
            formula: "estimated_level_2"
      level_3:
        formula: "missing_deep_entity + offset_3"
        alternate_states:
          UNAVAILABLE:
            formula: "fallback_level_3"
          UNKNOWN:
            formula: "estimated_level_3"
      offset_1: "10"
      offset_2: "20"
      offset_3: "30"
      fallback_level_1: "200"
      fallback_level_2: "150"
      fallback_level_3: "100"
      estimated_level_1: "180"
      estimated_level_2: "130"
      estimated_level_3: "80"
    metadata:
      unit_of_measurement: "W"
      device_class: "power"